# 338. [Подсчет Битов (Counting Bits)](https://leetcode.com/problems/counting-bits/description/)

`Easy`

Дано целое число `n`. Верните массив `ans` длины `n + 1` такой, что для каждого `i` (0 ≤ `i` ≤ `n`), `ans[i]` равно количеству **1** в двоичном представлении `i`.

**Пример 1:**
```
Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10
```

**Пример 2:**
```
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10
```

**Пример 2:**
```
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

**Ограничения:**

*   0 ≤ n ≤ 10⁵

**Дополнительные вопросы:**

*   Очень легко придумать решение со временем выполнения O(n log n). Можете ли вы сделать это за линейное время O(n) и, возможно, за один проход?
*   Можете ли вы сделать это без использования каких-либо встроенных функций (например, `__builtin_popcount` в C++)?