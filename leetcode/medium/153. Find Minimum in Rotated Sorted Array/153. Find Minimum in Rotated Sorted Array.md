# 153. [Найти минимум в повернутом отсортированном массиве (Find Minimum in Rotated Sorted Array)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)

сложность: `Medium`

Предположим, массив длины `n`, отсортированный в возрастающем порядке, повернут от 1 до `n` раз. Например, массив `nums = [0,1,2,4,5,6,7]` может стать:

*   [4,5,6,7,0,1,2], если он был повернут 4 раза.
*   [0,1,2,4,5,6,7], если он был повернут 7 раз.

Обратите внимание, что поворот массива `[a[0], a[1], a[2], ..., a[n-1]]` на 1 раз приводит к массиву `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Дан отсортированный повернутый массив `nums` из **уникальных** элементов, верните минимальный элемент этого массива.

Вы должны написать алгоритм, который работает за время O(log n).

```
Пример 1:

Input: nums = [3,4,5,1,2]
Output: 1
Объяснение: The original array was [1,2,3,4,5] rotated 3 times.

Пример 2:

Input: nums = [4,5,6,7,0,1,2]
Output: 0
Объяснение: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.

Пример 3:

Input: nums = [11,13,15,17]
Output: 11
Объяснение: The original array was [11,13,15,17] and it was rotated 4 times. 
```

**Ограничения:**

*   `n == nums.length`
*   `1 ≤ n ≤ 5000`
*   `-5000 ≤ nums[i] ≤ 5000`
*   Все целые числа в `nums` **уникальны**.
*   `nums` отсортирован и повернут от 1 до `n` раз.