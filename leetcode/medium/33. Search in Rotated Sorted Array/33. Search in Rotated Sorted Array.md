# 33. [Поиск в повернутом отсортированном массиве (Search in Rotated Sorted Array)](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

сложность: `Medium`

Дан целочисленный массив `nums`, отсортированный в возрастающем порядке (с **различными** значениями).

Перед передачей в вашу функцию, `nums` **возможно, был повернут** в неизвестной точке поворота `k` (`1 ≤ k < nums.length`) так, что результирующий массив имеет вид `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-индексированный). Например, `[0,1,2,4,5,6,7]` может быть повернут в точке поворота 3 и стать `[4,5,6,7,0,1,2]`.

Дан массив `nums` **после** возможного поворота и целое число `target`. Верните индекс `target`, если он находится в `nums`, или -1, если его там нет.

Вы должны написать алгоритм со сложностью по времени выполнения O(log n).

```
Пример 1:
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Пример 2:
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

Пример 2:
Input: nums = [1], target = 0
Output: -1
```

**Ограничения:**

*   `1 ≤ nums.length ≤ 5000`
*   `-10⁴ ≤ nums[i] ≤ 10⁴`
*   Все значения в `nums` **уникальны**.
*   `nums` - это возрастающий массив, который, возможно, повернут.
*   `-10⁴ ≤ target ≤ 10⁴`